<!DOCTYPE html>
<html lang="en">
<head>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta charset="utf-8"/>
  <title>Medical Guideline Query</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .container { max-width: 800px; margin: auto; }
    textarea { width: 100%; height: 100px; margin-top: 10px; }
    button { margin-top: 10px; padding: 10px 15px; font-size: 16px; }
    .output { margin-top: 20px; padding: 10px; border: 1px solid #ddd; background-color: #f9f9f9; }
    .json-output { margin-top: 20px; padding: 10px; border: 1px solid #ccc; background-color: #eef; }
    ul { margin: 0; padding-left: 20px; }
    li { margin-bottom: 5px; }
  </style>
  <!-- Import CryptoJS for AES decryption -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Medical Guideline Query</h1>
    <h6>Ask about conditions and get relevant guideline details</h6>
    
    <!-- Code Verification Section -->
    <div id="codeVerification">
      <p>To get the Company-generated code 'code engine', visit:</p>
      <a href="https://teams.microsoft.com/l/entity/a6b63365-31a4-4f43-92ec-710b71557af9/_djb2_msteams_prefix_3260863391?context=%7B%22channelId%22%3A%2219%3Aqj6QKba__DKmVPDBVyDkJ-Iz7U7M8pyl3BJZZPY_EX41%40thread.tacv2%22%7D&tenantId=8b3dd73e-4e72-4679-b191-56da1588712b" target="_blank">Get Company Code</a>
      <h2>Verify Your Code</h2>
      <input id="userCode" placeholder="Enter your code here" style="width: 95%; padding: 10px;" type="text"/>
      <button onclick="getVerificationCode()">Verify Code</button>
      <p id="result"></p>
    </div>

    <!-- Query Input -->
    <textarea disabled id="queryInput" placeholder="Enter your question here"></textarea>
    <button disabled id="findButton" onclick="processQuery()">Find Answer</button>

    <!-- AI Response Output -->
    <div class="output" id="aiOutput"></div>

    <!-- JSON Segments Display -->
    <div class="json-output" id="jsonSegments"></div>
  </div>

  <script>
    // ----------------------------------------------------
    // API Key Decryption & Code Verification (Base Code)
    // ----------------------------------------------------
    // Encrypted API Key (replace with your own encrypted string)
    const encryptedAPIKey = `JOzvSNtkCCIZX8YFcGL4/cWSwC9pyDKTstx3bLRwvAEllzQRMaH+bVk0gYBnp6XNsedYU98XZGCetlJfsCRUAQ==`;
    let apiKey = null;

    function unlockFeatures(decryptionKey) {
      if (!decryptionKey) {
        document.getElementById('result').innerText = "Decryption key not found.";
        return;
      }
      try {
        const parsedKey = CryptoJS.enc.Utf8.parse(decryptionKey);
        const decryptedAPIKeyBytes = CryptoJS.AES.decrypt(encryptedAPIKey.trim(), parsedKey, {
          mode: CryptoJS.mode.ECB,
          padding: CryptoJS.pad.Pkcs7
        });
        const decryptedAPIKey = decryptedAPIKeyBytes.toString(CryptoJS.enc.Utf8);
        if (!decryptedAPIKey) throw new Error("Incorrect decryption key for API key.");

        apiKey = decryptedAPIKey;
        document.getElementById('result').innerText = "Verification successful. You can now use the application.";
        document.getElementById('queryInput').disabled = false;
        document.getElementById('findButton').disabled = false;
        document.getElementById('codeVerification').style.display = 'none';
      } catch (error) {
        console.error("Decryption error:", error);
        document.getElementById('result').innerText = "Failed to decrypt API key. Please try again.";
      }
    }

    async function getVerificationCode() {
      const userCode = document.getElementById('userCode').value.trim();
      try {
        // Use your working verification endpoint
        const response = await fetch('https://verifycode-u7nxzgzwjq-uc.a.run.app/?code=' + userCode);
        if (!response.ok) throw new Error("Failed to verify the code");
        const result = await response.json();

        if (result.message === "Code verified!") {
          localStorage.setItem('userCode', userCode);
          document.getElementById('result').innerText = "Code verified successfully!";
          unlockFeatures(result.decryptionKey);
          document.getElementById('codeVerification').style.display = 'none';
        } else {
          document.getElementById('result').innerText = "Incorrect code. Please try again.";
        }
      } catch (error) {
        console.error("Verification error:", error);
        document.getElementById('result').innerText = "Error verifying the code.";
      }
    }

    // ----------------------------------------------------
    // Load Medical Guidelines JSON Data from rules.json
    // ----------------------------------------------------
    // Instead of an inline definition, we fetch the JSON from an adjacent file.
    let medicalData = {};
    fetch('rules.json')
      .then(response => {
        if (!response.ok) {
          throw new Error("Network response was not ok " + response.statusText);
        }
        return response.json();
      })
      .then(data => {
        medicalData = data;
        console.log("Loaded rules.json:", medicalData);
      })
      .catch(error => {
        console.error("Error loading rules.json:", error);
      });

    // ----------------------------------------------------
    // First Pass: Collect Relevant Guideline IDs Using GPT‑3.5
    // ----------------------------------------------------
async function getRelevantMeasureIDs(query) {
  // Convert the conditions object into an array of guideline entries.
  const guidelinesArray = Object.entries(medicalData.conditions).map(([title, guideline]) => ({
    title: title,
    measure_id: guideline.measure_id,
    // Join the keywords for easier display (you could also keep them as an array)
    keywords: guideline.keywords.join(', ')
  }));

  // Parameters for chunking and parallel calls
  const chunkSize = 5; // How many guidelines per GPT-3.5 call (adjust as needed)
  const maxParallelCalls = 3; // Maximum parallel GPT-3.5 calls
  const chunks = [];
  for (let i = 0; i < guidelinesArray.length; i += chunkSize) {
    chunks.push(guidelinesArray.slice(i, i + chunkSize));
  }

  let firstPassCandidates = [];

  // Process chunks in batches with a maximum of maxParallelCalls at a time.
  for (let i = 0; i < chunks.length; i += maxParallelCalls) {
    const currentBatch = chunks.slice(i, i + maxParallelCalls);
    // Create an array of promises for the current batch.
    const promises = currentBatch.map((batch, batchIndex) => {
      // Construct a user message for this batch.
      // Each entry shows its title, measure_id, and keywords.
      const messageContent =
        `User Query: "${query}"\n\n` +
        batch
          .map(entry =>
            `Guideline: ${entry.title} (Measure ID: ${entry.measure_id}; Keywords: ${entry.keywords})`
          )
          .join('\n');

      // Create the messages for GPT‑3.5.
      const messages = [
        {
          role: "system",
          content:
            "You are an AI that selects the most relevant medical guidelines based on the user's query. " +
            "From the provided list, select the guidelines that are most relevant and respond with the corresponding measure IDs, " +
            "each enclosed in double square brackets (e.g. [[BCS-E]]), separated by commas. " +
            "Output only the measure IDs."
        },
        { role: "user", content: messageContent }
      ];

      console.log(`Prompt for batch ${i + batchIndex + 1}:`, JSON.stringify(messages, null, 2));

      // Call GPT-3.5 for this batch.
      return callOpenAI(messages, "gpt-3.5-turbo");
    });

    // Wait for the current batch's responses.
    const results = await Promise.all(promises);

    // Process each result.
    results.forEach((response, index) => {
      console.log(`Response from GPT-3.5 (Batch ${i + index + 1}):`, response);
      // Extract measure IDs enclosed in [[...]]
      const extractedIDs =
        response.match(/\[\[([^\]]+)\]\]/g)?.map(match =>
          match.replace(/\[\[|\]\]/g, '').trim()
        ) || [];

      // If GPT-3.5 returned nothing for this batch, you might optionally use a backup keyword matcher.
      if (extractedIDs.length === 0) {
        console.warn(`No IDs returned from batch ${i + index + 1}; using backup matcher for this batch.`);
        extractedIDs.push(
          ...batchKeywordMatcher(currentBatch[index], query)
        );
      }

      console.log(`Extracted IDs from batch ${i + index + 1}:`, extractedIDs);
      firstPassCandidates = firstPassCandidates.concat(extractedIDs);
    });
  }

  // Remove duplicate measure IDs.
  firstPassCandidates = [...new Set(firstPassCandidates)];
  console.log("Final relevant measure IDs:", firstPassCandidates);
  return firstPassCandidates;
}

// A backup matcher that simply checks if any guideline's keywords (in the batch) appear in the query.
function batchKeywordMatcher(batchEntry, query) {
  const matchedIDs = [];
  const lowerQuery = query.toLowerCase();
  // Here, batchEntry is one guideline object from the batch.
  if (batchEntry.keywords.toLowerCase().includes(lowerQuery)) {
    matchedIDs.push(batchEntry.measure_id);
  }
  return matchedIDs;
}


    // ----------------------------------------------------
    // Second Pass: Answer the Query Using GPT‑4
    // ----------------------------------------------------
    async function getDetailedAnswer(query, relevantIDs) {
      // Gather the full JSON segments for each selected guideline.
      const relevantSegments = {};
      relevantIDs.forEach(id => {
        for (const key in medicalData) {
          if (medicalData[key].measure_id === id) {
            relevantSegments[id] = medicalData[key];
            break;
          }
        }
      });

      const detailedPrompt = [
        { role: "system", content: "You are an AI expert in medical guidelines. Given a user's query and the relevant guideline JSON segments (each identified by its measure_id), provide a concise answer to the query. Then, list the details of each relevant guideline as bullet points. Use the measure_id as the handle for each guideline. The response should include an 'Answer' section and a 'Details' section with bullet points." },
        { role: "user", content: `User Query: "${query}"\n\nRelevant Guidelines:\n${JSON.stringify(relevantSegments, null, 2)}` }
      ];

      return await callOpenAI(detailedPrompt, "gpt-4");
    }

    // ----------------------------------------------------
    // Process Query: Orchestrates Both Passes
    // ----------------------------------------------------
    async function processQuery() {
      const query = document.getElementById("queryInput").value.trim();
      if (!query) {
        alert("Please enter a question.");
        return;
      }
      if (!apiKey) {
        alert("API key not available. Please verify your code.");
        return;
      }
      // Ensure that medicalData has been loaded
      if (!Object.keys(medicalData).length) {
        alert("Guideline data not loaded yet. Please try again in a moment.");
        return;
      }

      document.getElementById("aiOutput").innerHTML = "Processing...";
      document.getElementById("jsonSegments").innerHTML = "";

      try {
        // First pass: get relevant measure IDs based on keywords (via GPT‑3.5)
        const relevantIDs = await getRelevantMeasureIDs(query);
        console.log("Relevant measure IDs:", relevantIDs);

        if (relevantIDs.length === 0) {
          document.getElementById("aiOutput").innerHTML = "No relevant guidelines found.";
          return;
        }

        // Second pass: get the detailed answer from GPT‑4 using the full JSON segments.
        const detailedAnswer = await getDetailedAnswer(query, relevantIDs);
        document.getElementById("aiOutput").innerHTML = `<strong>AI Response:</strong><br>${detailedAnswer}`;

        // Also display the relevant JSON segments in bullet-point format.
        let jsonHtml = `<strong>Relevant Guidelines Details:</strong><ul>`;
        relevantIDs.forEach(id => {
          for (const key in medicalData) {
            if (medicalData[key].measure_id === id) {
              const guideline = medicalData[key];
              jsonHtml += `<li>
                <strong>${guideline.measure_id}:</strong> ${key}<br>
                <strong>Description:</strong> ${guideline.description}<br>
                <strong>Measurement Period:</strong> ${guideline.measurement_period}<br>
                <strong>Ages:</strong> ${guideline.ages}<br>
                <strong>Best Practices:</strong>
                <ul>${guideline.best_practices.map(practice => `<li>${practice}</li>`).join('')}</ul>
              </li>`;
              break;
            }
          }
        });
        jsonHtml += `</ul>`;
        document.getElementById("jsonSegments").innerHTML = jsonHtml;
      } catch (error) {
        console.error("Error processing query:", error);
        document.getElementById("aiOutput").innerHTML = "An error occurred.";
      }
    }

    // ----------------------------------------------------
    // Function to Call OpenAI API
    // ----------------------------------------------------
    async function callOpenAI(messages, model) {
      if (!apiKey) {
        throw new Error("API key not available. Please verify your code.");
      }
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messages,
          temperature: 0.2,
          max_tokens: 500
        })
      });
      const data = await response.json();
      if (data.error) {
        throw new Error(data.error.message);
      }
      return data.choices[0].message.content;
    }
  </script>
</body>
</html>
