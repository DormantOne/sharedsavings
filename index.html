<!DOCTYPE html>
<html lang="en">
<head>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta charset="utf-8"/>
  <title>Medical Guideline Query</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .container { max-width: 800px; margin: auto; }
    textarea { width: 100%; height: 100px; margin-top: 10px; }
    button { margin-top: 10px; padding: 10px 15px; font-size: 16px; }
    .output { margin-top: 20px; padding: 10px; border: 1px solid #ddd; background-color: #f9f9f9; }
    .json-output { margin-top: 20px; padding: 10px; border: 1px solid #ccc; background-color: #eef; }
    ul { margin: 0; padding-left: 20px; }
    li { margin-bottom: 5px; }
  </style>
  <!-- Import CryptoJS for AES decryption -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Medical Guideline Query</h1>
    <h6>Ask about conditions and get relevant guideline details</h6>
    
    <!-- Code Verification Section -->
    <div id="codeVerification">
      <p>To get the Company-generated code 'code engine', visit:</p>
      <a href="https://teams.microsoft.com/l/entity/a6b63365-31a4-4f43-92ec-710b71557af9/_djb2_msteams_prefix_3260863391?context=%7B%22channelId%22%3A%2219%3Aqj6QKba__DKmVPDBVyDkJ-Iz7U7M8pyl3BJZZPY_EX41%40thread.tacv2%22%7D&tenantId=8b3dd73e-4e72-4679-b191-56da1588712b" target="_blank">Get Company Code</a>
      <h2>Verify Your Code</h2>
      <input id="userCode" placeholder="Enter your code here" style="width: 95%; padding: 10px;" type="text"/>
      <button onclick="getVerificationCode()">Verify Code</button>
      <p id="result"></p>
    </div>

    <!-- Query Input -->
    <textarea disabled id="queryInput" placeholder="Enter your question here"></textarea>
    <button disabled id="findButton" onclick="processQuery()">Find Answer</button>

    <!-- AI Response Output -->
    <div class="output" id="aiOutput"></div>

    <!-- JSON Segments Display -->
    <div class="json-output" id="jsonSegments"></div>
  </div>

  <script>
    // ----------------------------------------------------
    // API Key Decryption & Code Verification
    // ----------------------------------------------------
    const encryptedAPIKey = `JOzvSNtkCCIZX8YFcGL4/cWSwC9pyDKTstx3bLRwvAEllzQRMaH+bVk0gYBnp6XNsedYU98XZGCetlJfsCRUAQ==`;
    let apiKey = null;
    function unlockFeatures(decryptionKey) {
      if (!decryptionKey) {
        document.getElementById('result').innerText = "Decryption key not found.";
        return;
      }
      try {
        const parsedKey = CryptoJS.enc.Utf8.parse(decryptionKey);
        const decryptedAPIKeyBytes = CryptoJS.AES.decrypt(encryptedAPIKey.trim(), parsedKey, {
          mode: CryptoJS.mode.ECB,
          padding: CryptoJS.pad.Pkcs7
        });
        const decryptedAPIKey = decryptedAPIKeyBytes.toString(CryptoJS.enc.Utf8);
        if (!decryptedAPIKey) throw new Error("Incorrect decryption key for API key.");
        apiKey = decryptedAPIKey;
        document.getElementById('result').innerText = "Verification successful. You can now use the application.";
        document.getElementById('queryInput').disabled = false;
        document.getElementById('findButton').disabled = false;
        document.getElementById('codeVerification').style.display = 'none';
      } catch (error) {
        console.error("Decryption error:", error);
        document.getElementById('result').innerText = "Failed to decrypt API key. Please try again.";
      }
    }
    async function getVerificationCode() {
      const userCode = document.getElementById('userCode').value.trim();
      try {
        const response = await fetch('https://verifycode-u7nxzgzwjq-uc.a.run.app/?code=' + userCode);
        if (!response.ok) throw new Error("Failed to verify the code");
        const result = await response.json();
        if (result.message === "Code verified!") {
          localStorage.setItem('userCode', userCode);
          document.getElementById('result').innerText = "Code verified successfully!";
          unlockFeatures(result.decryptionKey);
          document.getElementById('codeVerification').style.display = 'none';
        } else {
          document.getElementById('result').innerText = "Incorrect code. Please try again.";
        }
      } catch (error) {
        console.error("Verification error:", error);
        document.getElementById('result').innerText = "Error verifying the code.";
      }
    }

    // ----------------------------------------------------
    // Load Medical Guidelines JSON Data from rules.json
    // ----------------------------------------------------
    let medicalData = {};
    fetch('rules.json')
      .then(response => {
        if (!response.ok) {
          throw new Error("Network response was not ok " + response.statusText);
        }
        return response.json();
      })
      .then(data => {
        medicalData = data;
        console.log("Loaded rules.json:", medicalData);
      })
      .catch(error => {
        console.error("Error loading rules.json:", error);
      });

    // ----------------------------------------------------
    // First Pass: Process guidelines in chunks with GPT-3.5
    // ----------------------------------------------------
    async function getRelevantMeasureIDs(query) {
      // Convert the conditions object to an array.
      const guidelinesArray = Object.entries(medicalData.conditions).map(([title, guideline]) => ({
        title: title,
        measure_id: guideline.measure_id,
        keywords: guideline.keywords.join(', ')
      }));

      // Set chunking parameters.
      const chunkSize = 5; // number of guidelines per GPT-3.5 call
      const maxParallelCalls = 3; // maximum parallel calls
      const chunks = [];
      for (let i = 0; i < guidelinesArray.length; i += chunkSize) {
        chunks.push(guidelinesArray.slice(i, i + chunkSize));
      }

      let firstPassCandidates = [];

      for (let i = 0; i < chunks.length; i += maxParallelCalls) {
        const currentBatch = chunks.slice(i, i + maxParallelCalls);
        const promises = currentBatch.map((batch, batchIndex) => {
          const messageContent =
            `User Query: "${query}"\n\n` +
            batch
              .map(entry =>
                `Guideline: ${entry.title} (Measure ID: ${entry.measure_id}; Keywords: ${entry.keywords})`
              )
              .join('\n');

          const messages = [
            {
              role: "system",
              content:
                "You are an AI that selects the most relevant medical guidelines based on the user's query. " +
                "From the provided list, select the guidelines that are most relevant and respond with the corresponding measure IDs, " +
                "each enclosed in double square brackets (e.g. [[BCS-E]]), separated by commas. " +
                "Output only the measure IDs."
            },
            { role: "user", content: messageContent }
          ];

          console.log(`Prompt for batch ${i + batchIndex + 1}:`, JSON.stringify(messages, null, 2));
          return callOpenAI(messages, "gpt-3.5-turbo");
        });

        const results = await Promise.all(promises);

        results.forEach((response, index) => {
          console.log(`Response from GPT-3.5 (Batch ${i + index + 1}):`, response);
          const extractedIDs =
            response.match(/\[\[([^\]]+)\]\]/g)?.map(match =>
              match.replace(/\[\[|\]\]/g, '').trim()
            ) || [];

          console.log(`Extracted IDs from batch ${i + index + 1}:`, extractedIDs);

          // Fallback: if GPT-3.5 returns nothing for this batch, use simple keyword matching.
          if (extractedIDs.length === 0) {
            console.warn(`No IDs from batch ${i + index + 1}; using fallback keyword matching.`);
            const fallbackIDs = currentBatch[index].filter(entry =>
              entry.keywords.toLowerCase().includes(query.toLowerCase())
            ).map(entry => entry.measure_id);
            console.log(`Fallback IDs for batch ${i + index + 1}:`, fallbackIDs);
            firstPassCandidates = firstPassCandidates.concat(fallbackIDs);
          } else {
            firstPassCandidates = firstPassCandidates.concat(extractedIDs);
          }
        });
      }

      // Remove duplicates.
      firstPassCandidates = [...new Set(firstPassCandidates)];
      console.log("Final relevant measure IDs:", firstPassCandidates);
      return firstPassCandidates;
    }

    // ----------------------------------------------------
    // Second Pass: Use GPT-4 with relevant guideline JSON segments
    // ----------------------------------------------------
    async function getDetailedAnswer(query, relevantIDs) {
      // Build a JSON object of relevant guideline segments from medicalData.conditions.
      const relevantSegments = {};
      relevantIDs.forEach(id => {
        for (const key in medicalData.conditions) {
          if (medicalData.conditions[key].measure_id === id) {
            relevantSegments[id] = medicalData.conditions[key];
            break;
          }
        }
      });

      console.log("Constructed Relevant Segments for GPT-4:", JSON.stringify(relevantSegments, null, 2));

      if (Object.keys(relevantSegments).length === 0) {
        return "I'm sorry, but I can't provide the help you're looking for without the relevant guideline JSON segments.";
      }

      const detailedPrompt = [
        {
          role: "system",
          content:
            "You are an AI expert in medical guidelines. Use the provided JSON object of relevant guideline segments to answer the user's query. Provide a concise answer and then list the details of each relevant guideline as bullet points, using the measure_id as the reference. Do not mention that the JSON is missing."
        },
        {
          role: "user",
          content: `User Query: "${query}"\n\nRelevant Guidelines:\n${JSON.stringify(relevantSegments, null, 2)}`
        }
      ];

      console.log("Detailed Prompt Sent to GPT-4:", JSON.stringify(detailedPrompt, null, 2));
      return await callOpenAI(detailedPrompt, "gpt-4");
    }

    // ----------------------------------------------------
    // Process Query: Orchestrate both passes
    // ----------------------------------------------------
    async function processQuery() {
      const query = document.getElementById("queryInput").value.trim();
      if (!query) {
        alert("Please enter a question.");
        return;
      }
      if (!apiKey) {
        alert("API key not available. Please verify your code.");
        return;
      }
      if (!medicalData.conditions || !Object.keys(medicalData.conditions).length) {
        alert("Guideline data not loaded yet. Please try again in a moment.");
        return;
      }

      document.getElementById("aiOutput").innerHTML = "Processing...";
      document.getElementById("jsonSegments").innerHTML = "";

      try {
        const relevantIDs = await getRelevantMeasureIDs(query);
        console.log("Relevant measure IDs:", relevantIDs);
        if (relevantIDs.length === 0) {
          document.getElementById("aiOutput").innerHTML = "No relevant guidelines found.";
          return;
        }
        const detailedAnswer = await getDetailedAnswer(query, relevantIDs);
        document.getElementById("aiOutput").innerHTML = `<strong>AI Response:</strong><br>${detailedAnswer}`;

        let jsonHtml = `<strong>Relevant Guidelines Details:</strong><ul>`;
        relevantIDs.forEach(id => {
          for (const key in medicalData.conditions) {
            if (medicalData.conditions[key].measure_id === id) {
              const guideline = medicalData.conditions[key];
              jsonHtml += `<li>
                <strong>${guideline.measure_id}:</strong> ${key}<br>
                <strong>Description:</strong> ${guideline.description}<br>
                <strong>Measurement Period:</strong> ${guideline.measurement_period}<br>
                <strong>Ages:</strong> ${guideline.ages}<br>
                <strong>Best Practices:</strong>
                <ul>${guideline.best_practices.map(practice => `<li>${practice}</li>`).join('')}</ul>
              </li>`;
              break;
            }
          }
        });
        jsonHtml += `</ul>`;
        document.getElementById("jsonSegments").innerHTML = jsonHtml;
      } catch (error) {
        console.error("Error processing query:", error);
        document.getElementById("aiOutput").innerHTML = "An error occurred.";
      }
    }

    // ----------------------------------------------------
    // Function to Call OpenAI API
    // ----------------------------------------------------
    async function callOpenAI(messages, model) {
      if (!apiKey) {
        throw new Error("API key not available. Please verify your code.");
      }
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messages,
          temperature: 0.2,
          max_tokens: 500
        })
      });
      const data = await response.json();
      if (data.error) {
        throw new Error(data.error.message);
      }
      return data.choices[0].message.content;
    }
  </script>
</body>
</html>
